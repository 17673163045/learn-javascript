<<<<<<< HEAD
```js
在es6中新引入了两种方式来申明变量，我们仍然可以使用广为传诵的var变量（然而你不应该继续使用它了，继续阅读来了解其中原因），但是现在我们有了两种更牛的工具去使用：let和const。
```

### let

```js
1.`let是块状作用域`，而var是函数作用域。

2.let`不能`在`定义之前`访问该变量（var是可以的，它确实是js世界中许多bug和困扰的源头）。

3.let`不能被重新定义`。
```

#### 作用域

```js
作用域是你可以在`特定区域内`使用的那些`变量（或者是函数）的声明`。作用域可以是`全局的`（因此在全局作用域中定义的变量可以在你代码中任何部分访问）`或者是局部`的。
```

```js
很显然，局部作用域只能在内部访问。在`ES6以前`，它仅仅允许一种方式来定义局部作用域 - `function`
```

```js
if(true){
    var a = 10;
    let b = 20;
}
console.log(a); // 在花括号外面打印,a为10
console.log(b); // 在花括号外面打印,b报错,b is not defined;
```



`一个经典的栗子`

```js
var arr = [];
for(var i = 0;i < 5;i++){
    arr.push(function(){
        console.log(i)
    })
};
arr[0](); //打印5
arr[1](); //打印5
arr[2](); //打印5
arr[3](); //打印5
arr[4](); //打印5
```

```js
为什么会打印5呢?而不是我们期望的0,1,2,3,4呢
    1.js不具备块级作用域,i在全局作用域都是可以访问的
	2.for循环完了之后,i在全局的值是5
	3.执行函数,访问i,访问的是全局的i,打印的当然是5
```

```js
这个时候,我们需要块级作用域!
    块就是由`花括号`括起来的`所有的内容`。所以它可以是`if`，`while`或者是`for`声明中的花括号，也可以是`单独的一个花括号`甚至是`一个函数`（对，函数作用域是块状作用域）
    所以我们知道,函数的花括号就是限制了一个块级作用域.但是在使用`let`和`const`之前,只有函数的花括号才具备块级作用域的作用.
```

`使用let和const来实现块级作用域`

```js
`let`和`const`是`块作用域`。意味着无论你在`块中`无论定义了什么变量，什么时候定义的，它都不会跑到块作用域外面去。
```

```js
if(true){
    //if的{}里面
    var varStr = "我是var声明的";
    let letStr = "我是let声明的";
    const constStr = "我是const声明的";
}
console.log(varStr); // 打印"我是var声明的"
console.log(letStr); // 报错letStr is not defined,let声明具有块级作用域,外面无法访问
console.log(constStr); // 报错,const声明具有块级作用域,外面无法访问
```

```js
所以,我们利用let,来达到我们之前的期望
    var arr = [];
    for(let i = 0;i < 5;i++){
        arr.push(function(){
            console.log(i)
        })
    };
    arr[0](); //打印0
    arr[1](); //打印1
    arr[2](); //打印2
    arr[3](); //打印3
    arr[4](); //打印4
```

```js
解释:
	1.因为我们用`let`定义i,所以i不是全局的了,i是局部的变量了.
    2.for循环,每次循环都会有一个块级作用域生成,块级作用域的值都是对应的0,1,2,3,4
	3.所以,每次函数执行,沿着作用域往上找,就会找到for循环的花括号{}里的i.
```

```js
所以,我们可以这么写:
function test(){
	let i = 10;
    if(true){
        let i = 20;
    }
	console.log(i);
} 
test(); //现在我们很容易知道打印的值为10
```

### 重复声明

```js
var可以重复声明,它的缺点是什么呢?
    比如你声明了一个变量,后面不小心又声明了同样的变量名称,
    就会在不知不觉中修改了你的代码,导致不易察觉的bug.
---------------------------------------------------
let是不可以重复声明的,
    好处是解决上面的问题,不会让你重复声明同一个变量覆盖之前的变量.
```

```js
var a = 10;
var a = true;
console.log(a); // true; 覆盖之前的10
------------------------------------
let b = 10;
let b = true;
console.log(b); //报错,b已经被声明过了
```

```js
注意:重复声明和重复赋值是不一样的
重复声明:
		let a = 10;
		let a = true;
		console.log(a); //报错
重复赋值:
		let a = 10;
		a = true;
		a = "hello";
		console.log(a); // hello
`let`:不可以重复声明,但是可以重复地赋值.
`const`:既不可以重复声明,也不可以重复赋值.
	const a = 10;
	a = 20;
	console.log(a); // 报错.
```



### 变量提升

```js
var声明的变量存在变量提升的问题,在于预编译过程,会将变量提升到作用域的顶层,初始值为undefined.
这有什么缺点?你可能不经意在声明变量之前就使用变量,导致不易察觉的bug,所以我们需要let
let声明的变量不允许变量提升.
```

```js
console.log(a); //可以打印undefined;
a = 10;  //在预编译的前提下再赋值,不会报错
var a; //尽管a在此声明,但是在预编译过程已经提升了,初始值为undefined
```

```js
b = 10; //报错,b不会在预编译环节提升了,因为使用let声明的,对一个不存在的变量直接赋值肯定报错.
let b;
```
















=======
1
>>>>>>> fb4d315a9bfba471dbaab9a573201a17e470cfc0

