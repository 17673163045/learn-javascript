###作用域

####[ [scope] ]

作用域是因为函数而产生的独特的东西。

每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供js引擎存取，[ [scope] ]就是这样一个属性。

函数对象的特殊属性[ [scope] ]，[ [scope] ]是一个隐式的属性，这个属性就是存储作用域的仓库。

**作用域链：**[ [scope] ]就是我们所说的作用域，其中存储了多个执行期上下文的集合，这个集合呈链式连接。这种链式连接叫做作用域链。

```js
function a(){
    ...
}
var global = 100; 
a();  
a();
// 1，在函数被定义的那一刻，a就有一个属性即a.[[scope]],a函数被定义了就产生了自己的作用域[[scope]];
// 2， a的作用域在被定义的那一刻就储存了Golbal Object,(GO对象)，即储存它出生环境的作用域链。
// 3， 在a函数执行时，产生了AO 对象，把AO 对象储存在作用域链里[[scope]]的第0位，此时把GO放在第1位。
    总结：每个函数都有自己的作用域链，函数被定义时作用域链就储存了父级的作用域链，函数执行时就会产生AO对象，把AO放在第0位，其他的链依次退一位排在后面。
```

用图片表示：

<img src = "https://user-gold-cdn.xitu.io/2018/4/1/1627ea21a29218f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" >

图片表示，函数add的作用域为[[scope]],在函数add被定义时，它的第0位储存了全局对象（GO）。

<img src = "https://user-gold-cdn.xitu.io/2018/4/1/1627e9f72e2364d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

图片表示：在add函数执行的那一刻，产生了活动对象（activity object）AO对象，此时AO对象排在第0位，其他的依次往后排。

<img src="https://user-gold-cdn.xitu.io/2018/4/1/1627ea255d0e29f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

图片表示：a()函数执行完之后，自己的AO对象被销毁，仍然储存着父级（也就是全局）的作用域链，即GO对象。

注意：函数被执行完作用域链的AO对象（函数自己的AO）被销毁，再次被执行就会再次生成AO，执行完再销毁。

####嵌套函数的作用域链生成

```js
function a(){
    function b(){
        var c = 234;
    }
    var c = 123;
    b();
    console.log(c)
}
var glob = 100;
a();
```

分析：

```js
// 1,函数a定义，a就生成了一个[[scope]]作用域，这里储存着global object，因为函数a是在全局作用域下定义的。
// 2,函数a执行，a就生成了执行期上下文，即AO对象，把AO对象放在最顶端。
// 3, 函数b在函数a里面，函数a的执行导致函数b的定义（产生），那么函数b也会生成自己的作用域链。因为b在a里面出生，所以函数b的[[scope]]作用域链刚开始就会有全局对象和函数a的AO对象。
```

上面的函数的作用域链用表格表示：

| 行为            | 描述                                                         | 产生的作用域链                                               |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **函数a定义  ** | **a在全局环境定义，它在定义的那一刻，它的作用域链存着全局的对象GO。** | **a.[[scope]]--->[ 0：GO ]**                                 |
| **函数a执行 **  | **函数a执行的时候，a会产生一个它自己的执行期上下文（AO对象），此时a的作用域链为    ** | **a.[[scope]]---> [ 0 : AO(a函数的AO),                                                               1  : GO（全局）]** |
| **函数b定义**   | **函数a的执行导致了它里面的函数b定义，此时b也有自己被定义的一刻的作用域链。** | **b.[[scope]]---> [ 0 : AO(a函数的AO), 1 : GO（全局）]，即b函数出生的环境为a，那么它就拿着a的劳动成果，拿着a的AO和全局GO。** |
| **函数b执行**   | **如果函数b执行了，那么它会产生自己的AO对象**                | **b.[[scope]]---> 0 ： AO（b函数的AO），1 : AO(a函数的AO), 2 : GO（全局）** |

**注意：a函数不执行，不会导致b函数定义，所以封装用立即执行函数，再用变量接收执行结果。**

---

---

---

###闭包

先看一个经典闭包例子

```js
var arr = [];
function a(){
    function b(){
        var bbb = 234;
        console.log(aaa)
    }
    arr.push(b)
}
a();
var aaa = 123;
console.log(arr)// 执行a函数，把a函数执行的结果赋给demo
arr[0]();   // 打印123；
```

```js
// 定义了函数a，函数a里面定义了一个函数b,函数a执行的最后是return b，即返回的值为函数b。
// demo = a(),demo此时就是函数a的返回值即函数b。 再执行demo()即执行函数b()
// 这就是闭包的一种写法，即在一个函数内部将函数内部的一些函数导出到外部全局环境执行。
```

从作用域链分析闭包：

```js
// 函数a执行生成了自己的作用域链，包括AO对象，GO对象。
// 函数a执行导致了函数b的定义，函数b定义时生成自己的作用域链，因为它出生在函数a的环境，那么它在定义的一刻就直接拿着函数a的劳动成果，所以函数b的作用域链包括 a的AO对象；GO对象。
// 函数b被保存到外部，等待被执行，直到demo()时，函数b被执行，执行时函数b生成自己的AO对象，此时函数b的作用域链为 b的AO对象，a的AO对象，GO对象。所以函数b可以访问和修改全局变量、a的AO对象的变量、以及自己的AO变量。
```

**但凡是内部函数被保存到外部，必定会产生闭包。**

闭包的案例：

数字累加：每调用一次函数，数字就++一次

```js
function a (){
    var num = 100
    function b(){
        num++;
        console.log(num);
    }
    return b;
}
var demo = a();
demo(); // 101；
demo(); // 102
demo();// 103
// 函数a里面写了 return b,把函数b保存到外部了，就产生了闭包。
// 在外部执行函数b，此时函数b的作用域链包含全局对象，函数a的AO对象，函数b自己的AO对象，它可以拿到所有变量。
// 调用一次函数b，即（demo()),函数b就在函数a的AO对象里num++修改num，再打印num；每次调用num都会++，再打印。
```

#### 闭包的危害

```js
// 当内部函数被保存到外部时，将会产生闭包。
// 闭包会导致原有的作用域链不释放，造成内存泄漏。
```

```js
// 如果不是特意做一个闭包应用，应该避免闭包，即避免将函数导到外部。
```

####闭包的应用

##### 实现公有变量 #####

数字累加器：每调用一次函数，数字就++一次

```js
function a (){
    var num = 100
    function b(){
        num++;
        console.log(num);
    }
    return b;
}
var demo = a();
demo(); // 101；
demo(); // 102
demo();// 103
// 函数a里面写了 return b,把函数b保存到外部了，就产生了闭包。
// 在外部执行函数b，此时函数b的作用域链包含全局对象，函数a的AO对象，函数b自己的AO对象，它可以拿到所有变量。
// 调用一次函数b，即（demo()),函数b就在函数a的AO对象里num++修改num，再打印num；每次调用num都会++，再打印。
```

#####做缓存（储存结构）

```js
function test(){
    var num = 100;
    function a(){
        num++；
        console.log(num);
    }
    function b(){
        num--;
        console.log(num);
    }
    return [a,b]
}
var arr = test();
arr[0]();   // 打印101
arr[1]();   // 打印100
// 通过数组把函数a和函数b保存到外部，形成闭包。
```

```js
function eater(){
    var food = "";   // 创建food
    var obj = {
        eat : function(){
            if(food == ""){
                console.log("no food");
            }else{
                console.log("I am eating" + food);
                food = "";
                 }          // 对象里面有一个eat属性，eat属性的函数方法是清空食物  
        },  // 对象的属性用逗号隔开。
        push : function(myfood){
            food = myfood;
        }  // 对象有一个添加食物的属性方法。
    }
    return obj; // 返回对象，对象里面有函数，这样也形成了一个闭包。
} 
var eater1 = eater(); // eater1接收了函数返回的对象，对象里面有函数。
eater1.eat();  // eater1调用对象里的eat方法
eater1.push("香蕉");  // 调用添加食物的方法。
```

##### 实现封装，属性私有化

```js

```



##### 模块化开发，防止全局变量污染

```js

```

---

---

---

###立即执行函数与闭包

闭包触发的问题

```js
function test(){   
    var arr = [];       //定义空数组
    for(var i = 0; i < 10; i++){     // 10次循环
        arr[i] = function(){    //  每次循环都赋给arr一个函数
            console.log(i)   // 函数的作用是打印i
        }
    }
    return arr;   // 返回arr，此时arr里面有10个函数,即形成了闭包
}
var arr2 = test();
for ( j = 0;j < 10;j++){
    arr2[j]();
} // 分别执行arr2里面的函数
// 打印10个10。
// 为什么会打印10个10而不是打印0,1,2,3,4,5,6,7,8,9
/* arr[i] = function(){   
            console.log(i) 
        }
        在把函数赋给数组的每一位时候，函数并没有被执行,函数在被保存到外面之后执行，这个时候函数访问变量i，而不是在循环的时候每次都打印i。
        在外面执行的时候访问i到test函数的AO去找i，AO的i变量在循环结束后的值为10，所以打印10。
*/
```

立即执行函数解决闭包

```js
// 现在我们就要让数组的函数分别保存打印0-9的功能。
function test(){   
   var arr = [];
        for (var i = 0; i < 10; i++) {
            (function (j) {
                arr[j] = function () {
                    console.log(j)
                }
            }(i)) 
    return arr;   // 返回arr，此时arr里面有10个函数,即形成了闭包
}
var arr2 = test();
for ( j = 0;j < 10;j++){
    arr2[j]();
} 

            // 每次循环都生成了一个独一无二的立即执行函数，它们都会生成AO,它们的变量j为对应的i
            // 立即执行函数传入参数i,立即执行函数也会生成AO，那么它会保存j变量即i的值，那么闭包函数到外面执行时找j变量就会找到立即执行函数的AO对象。
        }
        arr.forEach(el => {
            el()
        })
// 打印0,1,2,3,4,5,6,7,8,9
```



